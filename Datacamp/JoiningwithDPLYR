joining two dataframes works well with this. It kind of works like vlookup,
adding the values for a second dataframe to a first dataframe based on a specific variable. 

# Complete the code to join artists to bands
bands
bands2 <- left_join(bands, artists, by = c("first", "last"))

# Examine the results
bands2

# Fix the code to recreate bands2
bands2 <- left_join(bands, artists, by = c("first", "last"))
bands2

# Finish the code below to recreate bands3 with a right join
bands2 <- left_join(bands, artists, by = c("first", "last"))
bands3 <- right_join(artists, bands, by=c("first", "last"))

# Check that bands3 is equal to bands2
setequal(bands3, bands2)

right joining basically means that the secondary key becomes the first and the other way around. 

# Join albums to songs using inner_join()
inner_join(songs, albums, by = "album")
Inner join only retains those rows in the dataset that occur in both tables

# Join bands to artists using full_join()
full_join(artists, bands)
full join retains all rows across both datasets. 

# Find guitarists in bands dataset (don't change)
temp <- left_join(bands, artists, by = c("first", "last"))
temp <- filter(temp, instrument == "Guitar")
select(temp, first, last, band)

# Reproduce code above using pipes
bands %>% 
  left_join(artists, by = c("first", "last")) %>%
  filter(instrument == "Guitar") %>%
  select(first, last, band)
  
  # Examine the contents of the goal dataset
goal

# Create goal2 using full_join() and inner_join() 
goal2 <- artists %>%
full_join(bands, by= c("first", "last"))%>%
inner_join(songs, by= c("first", "last"))
  
  
  
# Check that goal and goal2 are the same
setequal(goal, goal2)

# Create one table that combines all information
artists %>%
full_join(bands, by=c("first", "last"))%>%
full_join(songs, by=c("first", "last")) %>%
full_join(albums, by=c("album", "band"))

semi_join: easy to figure out whether there is a match in the second data frame for the given first data frame. 
# View the output of semi_join()
artists %>% 
  semi_join(songs, by = c("first", "last"))

# Create the same result
artists %>% 
  right_join(songs, by = c("first", "last")) %>% 
  filter(!is.na(instrument)) %>% 
  select(first, last, instrument)
  albums %>% 
  # Collect the albums made by a band
  semi_join(bands, by = "band") %>% 
  # Count the albums made by a band
  nrow()
  
  anti_join() to see which rows will not have a match, to check which rows might have a mistake or a typo. 
  
  # Return rows of artists that don't have bands info
artists %>% 
  anti_join(bands, by= c("first", "last"))
  
  # Check whether album names in labels are mis-entered
labels %>% 
  anti_join(albums, by = "album")
  
  # Determine which key joins labels and songs
labels
songs

# Check your understanding
songs %>% 
  # Find the rows of songs that match a row in labels
  inner_join(labels, by = "album") %>% 
  # Number of matches between labels and songs
  nrow()
  
  Set operations: 
  union(names, more_names) will return to one or more oft he datasets. 
  intersect() only those that will return in both
  setdiff() will return only the ones that exist in the first but not the second. 
  
  aerosmith %>% 
  # Create the new dataset using a set operation
  union(greatest_hits) %>% 
  # Count the total number of songs
  nrow()
  # Create the new dataset using a set operation
aerosmith %>% 
  intersect(greatest_hits)
  # Select songs from live and greatest_hits
live_songs <- live %>% select(song)
greatest_songs <- greatest_hits %>% select(song)


# Find songs in at least one of live_songs and greatest_songs
all_songs <- union(live_songs, greatest_songs)

# Find songs in both 
common_songs <- intersect(live_songs, greatest_songs)

# Find songs that only exist in one dataset
setdiff(all_songs, common_songs)
  
  # Select the song names from live
live_songs <- live %>% select(song)
live
greatest_hits
# Select the song names from greatest_hits
greatest_songs <- greatest_hits %>% select(song)

# Create the new dataset using a set operation
live_songs %>% 
  setdiff(greatest_songs)
  
 Comparing datasets
 dataframe and tibble methods. 
setequal(names of the datasets) 
returns = true or false. 
identical(names of datasets), but only returns true if the location of the rows is idential in both. 

mutating joins: left, right, innner, full

# Check if same order: definitive and complete
identical(definitive, complete)

# Check if any order: definitive and complete
setequal(definitive, complete)

# Songs in definitive but not complete
setdiff(definitive, complete)


# Songs in complete but not definitive
setdiff(complete, definitive)
# Return songs in definitive that are not in complete
definitive %>% 
  setdiff(complete)

# Return songs in complete that are not in definitive
complete %>% 
setdiff(definitive)

# Get union of complete and soundtrack
complete_and_soundtrack <- union(complete, soundtrack)


# Check if same, including order: definitive and union of complete and soundtrack
complete_and_soundtrack %>%
identical(definitive)


# Check if same, rows in any order: definitive and union of complete and soundtrack
complete_and_soundtrack %>%
setequal(definitive)
